/*
Copyright 2015 Bowler Hat LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/// <reference path="./as3.ts" />

import as3 = require("./as3");

let NEW_LINE = "\n";

let AS_TO_EXTERNS_TYPE_MAP = {};
AS_TO_EXTERNS_TYPE_MAP[as3.BuiltIns[as3.BuiltIns.Number]] = "number";
AS_TO_EXTERNS_TYPE_MAP[as3.BuiltIns[as3.BuiltIns.Boolean]] = "boolean";
AS_TO_EXTERNS_TYPE_MAP[as3.BuiltIns[as3.BuiltIns.String]] = "string";

class JSExternsEmitter
{
	constructor(types: as3.PackageLevelDefinition[])
	{
		this._types = types;
	}
	
	private _types: as3.PackageLevelDefinition[];
	
	emitFileHeader(): string
	{
		var header = "/**" + NEW_LINE;
 		header += " * @fileoverview Externs generated by dts2as from NextGenActionScript.com" + NEW_LINE;
		header += " * @externs" + NEW_LINE;
		header += " * @suppress {duplicate}" + NEW_LINE;
 		header += " */" + NEW_LINE + NEW_LINE;
		return header;
	}
	
	emitPackages(): string
	{
		let packages: string[] = [];
		let packagesOutput = "";
		this._types.forEach((as3Type: as3.PackageLevelDefinition) =>
		{
			if(as3Type.external)
			{
				return;
			}
			let packageName = as3Type.packageName;
			if(packageName.length > 0)
			{
				let packageParts = packageName.split(".");
				while(packageParts.length > 0)
				{
					let currentPackage = packageParts.join(".");
					packageParts.pop();
					let existingType = as3.getDefinitionByName(currentPackage, this._types);
					if(existingType || packages.indexOf(currentPackage) >= 0)
					{
						continue;
					}
					packages.push(currentPackage);
					let packageOutput = "/**" + NEW_LINE;
					packageOutput += " * @type {Object}" + NEW_LINE;
					packageOutput += " */" + NEW_LINE;
					if(packageParts.length === 0)
					{
						packageOutput += "var ";
					}
					packageOutput += currentPackage + " = {};" + NEW_LINE + NEW_LINE;
					packagesOutput += packageOutput;
				}
			}
		});
		return packagesOutput;
	}
	
	emitClass(as3Class: as3.ClassDefinition): string
	{
		let className = as3Class.getFullyQualifiedName();
		let superClass = as3Class.superClass;
		let interfaces = as3Class.interfaces;
		let constructorMethod = this.getConstructorMethod(as3Class);
		
		let classOutput = "/**" + NEW_LINE;
		classOutput += " * @constructor" + NEW_LINE;
		if(superClass)
		{
			classOutput += " * @extends {";
			classOutput += this.getNameToEmit(superClass, as3Class);
			classOutput += "}" + NEW_LINE;
		}
		if(interfaces.length > 0)
		{
			interfaces.forEach((otherInterface, index) =>
			{
				classOutput += " * @implements {";
				classOutput += this.getNameToEmit(otherInterface, as3Class);
				classOutput += "}" + NEW_LINE;
			});
		}
		if(constructorMethod)
		{
			classOutput += this.emitParameterDocs(constructorMethod, as3Class);
		}
		classOutput += " */" + NEW_LINE;
		if(className === as3Class.name)
		{
			classOutput += "var ";
		}
		classOutput += className;
		classOutput += " = function";
		if(constructorMethod)
		{
			classOutput += this.emitParameters(constructorMethod, as3Class);
		}
		else
		{
			classOutput += "()";
		}
		classOutput += " {}" + NEW_LINE;
		classOutput += NEW_LINE;
		
		//static properties and methods first
		as3Class.properties.forEach((property: as3.PropertyDefinition) =>
		{
			if(!property.isStatic)
			{
				return;
			}
			classOutput += this.emitProperty(property, as3Class);
			classOutput += NEW_LINE + NEW_LINE;
		});
		
		as3Class.methods.forEach((method: as3.MethodDefinition) =>
		{
			if(!method.isStatic)
			{
				return;
			}
			classOutput += this.emitMethod(method, as3Class);
			classOutput += NEW_LINE + NEW_LINE;
		});
		
		as3Class.properties.forEach((property: as3.PropertyDefinition) =>
		{
			if(property.isStatic || as3.requiresClassOverride(property, as3Class))
			{
				return;
			}
			classOutput += this.emitProperty(property, as3Class);
			classOutput += NEW_LINE + NEW_LINE;
		});
		
		as3Class.methods.forEach((method: as3.MethodDefinition) =>
		{
			if(method.isStatic || as3.requiresClassOverride(method, as3Class))
			{
				return;
			}
			classOutput += this.emitMethod(method, as3Class);
			classOutput += NEW_LINE + NEW_LINE;
		});
		
		return classOutput;
	}
	
	emitInterface(as3Interface: as3.InterfaceDefinition): string
	{
		let interfaceName = as3Interface.getFullyQualifiedName();
		let interfaces = as3Interface.interfaces;
		
		let interfaceOutput = "/**" + NEW_LINE;
		interfaceOutput += " * @interface" + NEW_LINE;
		if(interfaces.length > 0)
		{
			interfaces.forEach((otherInterface, index) =>
			{
				interfaceOutput += " * @extends {";
				interfaceOutput += this.getNameToEmit(otherInterface, as3Interface);
				interfaceOutput += "}" + NEW_LINE;
			});
		}
		interfaceOutput += " */" + NEW_LINE;
		if(interfaceName === as3Interface.name)
		{
			interfaceOutput += "var ";
		}
		interfaceOutput += interfaceName;
		interfaceOutput += " = function() {};";
		interfaceOutput += NEW_LINE;
		
		as3Interface.properties.forEach((property: as3.PropertyDefinition) =>
		{
			if(as3.requiresInterfaceOverride(property, as3Interface))
			{
				return;
			}
			interfaceOutput += this.emitProperty(property, as3Interface);
			interfaceOutput += NEW_LINE + NEW_LINE;
		});
		
		as3Interface.methods.forEach((method: as3.MethodDefinition) =>
		{
			if(as3.requiresInterfaceOverride(method, as3Interface))
			{
				return;
			}
			interfaceOutput += this.emitMethod(method, as3Interface);
			interfaceOutput += NEW_LINE + NEW_LINE;
		});
		return interfaceOutput;
	}
	
	emitPackageFunction(as3PackageFunction: as3.PackageFunctionDefinition): string
	{
		return this.emitMethod(as3PackageFunction, as3PackageFunction) + NEW_LINE + NEW_LINE;
	}
	
	emitPackageVariable(as3PackageVariable: as3.PackageVariableDefinition): string
	{
		return this.emitVariable(as3PackageVariable, as3PackageVariable) + NEW_LINE + NEW_LINE;
	}
	
	private getNameToEmit(target:as3.PackageLevelDefinition, scope:as3.PackageLevelDefinition): string
	{
		if(!target)
		{
			return "*";
		}
		let fullyQualifiedName = target.getFullyQualifiedName();
		if(fullyQualifiedName in AS_TO_EXTERNS_TYPE_MAP)
		{
			return AS_TO_EXTERNS_TYPE_MAP[fullyQualifiedName];
		}
		return fullyQualifiedName;
	}
	
	private addMemberImports(as3Type: as3.TypeDefinition, imports: string[])
	{
		as3Type.properties.forEach((as3Property) =>
		{
			this.addPropertyImport(as3Property, as3Type, imports);
		});
		as3Type.methods.forEach((as3Method) =>
		{
			this.addMethodImport(as3Method, as3Type, imports);
		});
	}
	
	private addPropertyImport(as3Property: as3.PropertyDefinition, as3Type: as3.PackageLevelDefinition, imports: string[])
	{
		let propertyType = as3Property.type;
		if(!as3.requiresImport(propertyType, as3Type))
		{
			return;
		}
		imports.push(propertyType.getFullyQualifiedName());
	}
	
	private addMethodImport(as3Method: as3.MethodDefinition, as3Type: as3.PackageLevelDefinition, imports: string[])
	{
		let methodType = as3Method.type;
		if(as3.requiresImport(methodType, as3Type))
		{
			imports.push(methodType.getFullyQualifiedName());
		}
		this.addParametersImports(as3Method, as3Type, imports);
	}
	
	private addParametersImports(as3Function: as3.FunctionDefinition, as3Type: as3.PackageLevelDefinition, imports: string[])
	{
		as3Function.parameters.forEach((parameter: as3.ParameterDefinition) =>
		{
			let parameterType = parameter.type;
			if(as3.requiresImport(parameterType, as3Type))
			{
				imports.push(parameterType.getFullyQualifiedName());
			} 
		});
	}
	
	private emitMethod(as3Method: as3.MethodDefinition, scope: as3.PackageLevelDefinition): string
	{
		let scopeFullyQualifiedName = scope.getFullyQualifiedName();
		let methodName = as3Method.name;
		let methodType = as3Method.type;
		let isStatic = as3Method.isStatic;
		
		let methodOutput = "/**" + NEW_LINE;
		methodOutput += this.emitParameterDocs(as3Method, scope);
		if(methodType.name !== as3.BuiltIns[as3.BuiltIns.void])
		{
			methodOutput += " * @return {" + this.getNameToEmit(methodType, scope) + "}" + NEW_LINE;
		}
		methodOutput += " */" + NEW_LINE;
		if(as3Method instanceof as3.PackageFunctionDefinition &&
			!as3Method.packageName)
		{
			methodOutput += "function ";
			methodOutput += scopeFullyQualifiedName;
		}
		else
		{
			methodOutput += scopeFullyQualifiedName;
			if("methods" in scope)
			{
				if(isStatic)
				{
					methodOutput += ".";
				}
				else
				{
					methodOutput += ".prototype.";
				}
				methodOutput += methodName;
			}
			methodOutput += " = function";
		}
		methodOutput += this.emitParameters(as3Method, scope);
		methodOutput += " {};";
		return methodOutput;
	}
	
	private emitProperty(as3Property: as3.PropertyDefinition, scope: as3.PackageLevelDefinition): string
	{
		let scopeFullyQualifiedName = scope.getFullyQualifiedName();
		let propertyName = as3Property.name;
		let propertyType = as3Property.type;
		let isStatic = as3Property.isStatic;
		
		let propertyOutput = "/**" + NEW_LINE;
		propertyOutput += " * @type {" + this.getNameToEmit(propertyType, scope) + "}" + NEW_LINE;
		propertyOutput += " */" + NEW_LINE;
		propertyOutput += scopeFullyQualifiedName;
		if(isStatic)
		{
			propertyOutput += ".";
		}
		else
		{
			propertyOutput += ".prototype.";
		}
		propertyOutput += propertyName;
		propertyOutput += ";";
		return propertyOutput;
	}
	
	private emitVariable(as3Property: as3.PropertyDefinition, scope: as3.PackageLevelDefinition): string
	{
		let propertyName = as3Property.name;
		let propertyType = as3Property.type;
		
		let propertyOutput = "/**" + NEW_LINE;
		propertyOutput += " * @type {" + this.getNameToEmit(propertyType, scope) + "}" + NEW_LINE;
		propertyOutput += " */" + NEW_LINE;
		propertyOutput += "var ";
		propertyOutput += propertyName;
		propertyOutput += ";";
		
		return propertyOutput;
	}
	
	private emitParameterDocs(as3Function: as3.FunctionDefinition, scope: as3.PackageLevelDefinition): string
	{   
		let parameters = as3Function.parameters;
		
		let parametersOutput = "";
		if(parameters)
		{
			for(let i = 0, count = parameters.length; i < count; i++)
			{
				let parameter = parameters[i];
				parametersOutput += " * @param {";
				if(parameter.isRest)
				{
					parametersOutput += "...Object";
				}
				else
				{
					let parameterType = parameter.type;
					if(parameterType)
					{
						parametersOutput += this.getNameToEmit(parameterType, scope);
					}
					else
					{
						parametersOutput += "?";
					}
					if(parameter.value !== null)
					{
						parametersOutput += "=";
					}
				}
				parametersOutput += "} ";
				parametersOutput += parameter.name;
				parametersOutput += NEW_LINE;
			}
		}
		return parametersOutput;
	}
	
	private emitParameters(as3Function: as3.FunctionDefinition, scope: as3.PackageLevelDefinition): string
	{   
		let parameters = as3Function.parameters;
		
		let signatureOutput = "(";
		if(parameters)
		{
			for(let i = 0, count = parameters.length; i < count; i++)
			{
				let parameter = parameters[i];
				if(i > 0)
				{
					signatureOutput += ", ";
				}
				signatureOutput += parameter.name;
			}
		}
		signatureOutput += ")";
		return signatureOutput;
	}
	
	private getConstructorMethod(as3Class: as3.ClassDefinition): as3.ConstructorDefinition
	{
		let constructorMethod = as3Class.constructorMethod;
		if(constructorMethod)
		{
			return constructorMethod;
		}
		let superClass = as3Class.superClass;
		if(superClass)
		{
			return this.getConstructorMethod(superClass);
		}
		return null;
	}
}

export = JSExternsEmitter;